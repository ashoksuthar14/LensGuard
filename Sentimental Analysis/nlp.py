# -*- coding: utf-8 -*-
"""NLP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14F7z05dCLVjI_keeCouLQu6WLJXKnt9V
"""

## Start
import numpy as np
import pandas as pd
from transformers import BertTokenizer, BertForSequenceClassification, pipeline
from transformers import BartForConditionalGeneration, BartTokenizer
from sklearn.preprocessing import MinMaxScaler

sentiment_model = BertForSequenceClassification.from_pretrained('nlptown/bert-base-multilingual-uncased-sentiment')
tokenizer = BertTokenizer.from_pretrained('nlptown/bert-base-multilingual-uncased-sentiment')

bart_model = BartForConditionalGeneration.from_pretrained('facebook/bart-large-cnn')
bart_tokenizer = BartTokenizer.from_pretrained('facebook/bart-large-cnn')

reviews = [
    "The lens produces sharp images, but the focus ring is a bit stiff.",
    "Color reproduction is outstanding, but the lens tends to flare in bright sunlight.",
    "The aperture control is smooth, but the lens hood is not well-designed.",
    "The bokeh effect is beautiful, but the lens is quite prone to dust."

]

ratings = [
   {'sharpness': 5, 'focus_ring': 3, 'color_reproduction': 5, 'flare': 2, 'aperture_control': 4, 'lens_hood': 2, 'bokeh': 5, 'dust_resistance': 2},
    {'sharpness': 4, 'focus_ring': 2, 'color_reproduction': 5, 'flare': 3, 'aperture_control': 5, 'lens_hood': 3, 'bokeh': 4, 'dust_resistance': 3},
    {'sharpness': 5, 'focus_ring': 4, 'color_reproduction': 4, 'flare': 2, 'aperture_control': 5, 'lens_hood': 2, 'bokeh': 5, 'dust_resistance': 2},
    {'sharpness': 4, 'focus_ring': 3, 'color_reproduction': 4, 'flare': 3, 'aperture_control': 4, 'lens_hood': 1, 'bokeh': 5, 'dust_resistance': 2}

]

def sentiment_analysis(review):
    inputs = tokenizer.encode(review, return_tensors="pt", max_length=512, truncation=True)
    outputs = sentiment_model(inputs)
    probs = outputs[0].softmax(1)
    return int(np.argmax(probs)) + 1

def aspect_based_sentiment_analysis(review):
    aspects = ['zoom', 'cap_quality', 'stabilization','autofocus','build_quality','weight']
    aspect_sentiments = {}

    for aspect in aspects:
        if aspect in review.lower():
            aspect_sentiments[aspect] = sentiment_analysis(review)

    return aspect_sentiments

def summarize_reviews(reviews):
    inputs = bart_tokenizer(" ".join(reviews), return_tensors="pt", max_length=1024, truncation=True)
    summary_ids = bart_model.generate(inputs['input_ids'], max_length=150, min_length=40, length_penalty=2.0, num_beams=4, early_stopping=True)
    summary = bart_tokenizer.decode(summary_ids[0], skip_special_tokens=True)
    return summary

def aggregate_metrics(ratings):
    df = pd.DataFrame(ratings)
    return df.mean().to_dict()

def make_decision(aspect_sentiments, aggregated_metrics):
    threshold = 3.0  # Arbitrary threshold for making decisions
    decision = "Keep"

    if any(value < threshold for value in aggregated_metrics.values()):
        decision = "Throw"
    elif any(value < threshold for value in aspect_sentiments.values()):
        decision = "Reinspect"

    return decision

def sentiment_analysis(review):
    inputs = tokenizer.encode(review, return_tensors="pt", max_length=512, truncation=True)
    outputs = sentiment_model(inputs)
    probs = outputs[0].softmax(1)
    # Detach the tensor and convert it to a numpy array
    probs_np = probs.detach().numpy()
    return int(np.argmax(probs_np)) + 1  # Returns sentiment score from 1 to 5

# Call the summarize_reviews function with the reviews data
summary = summarize_reviews(reviews)

summary_report = {
    "summary": summary,
    "aspect_sentiments": aggregated_aspect_sentiments,
    "aggregated_metrics": aggregated_metrics,
    "final_decision": decision
}

aspect_sentiments = []
for review in reviews:
    # Ensure aspect_based_sentiment_analysis returns data in the expected format
    result = aspect_based_sentiment_analysis(review)
    if result:  # Check if the result is not empty
        aspect_sentiments.append(result)

# Check if aspect_sentiments is not empty before proceeding
if aspect_sentiments:
    aggregated_aspect_sentiments = pd.DataFrame(aspect_sentiments).mean().to_dict()
else:
    # Handle the case where aspect_sentiments is empty
    aggregated_aspect_sentiments = {}  # Or provide a default value

aggregated_metrics = aggregate_metrics(ratings)
summary = summarize_reviews(reviews)
decision = make_decision(aggregated_aspect_sentiments, aggregated_metrics)

summary_report = {
    "summary": summary,
    "aspect_sentiments": aggregated_aspect_sentiments,
    "aggregated_metrics": aggregated_metrics,
    "final_decision": decision
}

print("Summary Report:")
for key, value in summary_report.items():
    print(f"{key.capitalize()}: {value}")